<!DOCTYPE html>
<html lang="en">
  <head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="Lencerf" name="author">
<meta property="og:title" content="Virtio, vhost, vhost-user, vsock, etc. - Lencerf&#39;s Walk">
<meta property="og:description" content="to hit the marked point">
<meta property="og:type" content="website">
<title>Virtio, vhost, vhost-user, vsock, etc. | Lencerf&#39;s Walk</title>
<link rel="stylesheet" href="../../css/style.css">
<script src="https://kit.fontawesome.com/8455592b61.js"></script>



<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/3.1.8/imagesloaded.pkgd.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.css" media="screen" type="text/css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.pack.js"></script>
<script src="../../js/gallery.js" defer></script>




</head>
  <body>
        <div id="homeWhite" style="margin-top:30px"></div>
    <header class="section">
      <nav class="nav">
        <div class="nav-left">
          <h1 class="page-title">
            <a class="nav-item" href="../../">Lencerf&#39;s Walk</a>
          </h1>
        </div>
        <div class="nav-right">
          
        </div>
      </nav>
    </header>
    
    <article class="section">
    
      <h1 class="title">Virtio, vhost, vhost-user, vsock, etc.</h1>
        
        <time class="meta">May 28, 2023</time>
        
      <div class="meta">
        
          <span class="metagroup">
            
            
            <i class="fa fa-folder-o" aria-hidden="true"></i>
            <a href="../../categories/technology" rel="category">Technology</a>
            
          </span>
        
        
          <span class="metagroup">
            
              <i class="fa fa-tag" aria-hidden="true"></i>
            
            
              
              <a href="../../tags/virtualization/" rel="tag">Virtualization</a>
            
          </span>
        
      </div>
      <main class="content entry-content entry clearfix">
        <p>In virtualization technologies, there are a lot of terminologies starting with
letter <code>v</code>, this article gives a very brief introduction to these words from my
understandings. Checks the links at the end for more details.</p>
<h2 id="virtio-and-virtqueue">Virtio and virtqueue</h2>
<p><strong>Virtio</strong><sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> is a standard<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> to implement virtual
devices. The name comes from &ldquo;virtual IO&rdquo;. A virtual device is different from an
emulated real device. Consider a network interface card. An OS uses drivers to
operate a real NIC to send and receive packets. To emulate such a real NIC in a
virtual machine, developers have to implement every detail of this NIC to make
it appear as a bare-metal NIC to the VM&rsquo;s OS. This reverse engineering process
is troublesome and the emulated NIC usually does not have a satisfying
performance.</p>
<p>To enhance performance and also simplify a virtual machine, para-virtualization
and virtual devices were introduced. Para-virtualization means we do not
emulated a full bare-metal virtual machine, instead, the VM&rsquo;s OS is informed
that it is running in a virtualized environment. For example, the network
packets generated by the VM are usually forwarded to the host OS for further
processing, thus in the simplest case, the VM can just put the packet data in a
buffer and then instruct the host OS to handle it. A fully-emulated NIC is
not necessary within the VM.</p>
<p>Virtio established a common framework for implementing a virtual NIC, block
device, random number generator, etc. The mechanism for the guest OS and the VMM to
share data is <strong>virtqueue</strong>, a ring buffer. Virtual machine softwares (QEMU,
VMWare, etc.) presents virtio devices to the guest OS and the guest OS uses
special virtio drivers (different from the drivers for a real NIC) to operate
virtio devices. When data is to be sent out, the guest drivers place data in the
out-queue and trigger an VM exit. Conversely when data is received, the virtual
machine software (QEMU, VMWare, etc.) inserts it to the in-queue and injects an
interrupt to the guest OS.</p>
<h2 id="vhost">Vhost</h2>
<p><strong>Vhost</strong><sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> is a mechanism, or a protocol, for off-loading the data
plane of virtio devices to another process. Why do we need off-loading? from my
understandings, two reasons: performance and modularization.</p>
<h3 id="performance-kernel-devvhost--devices">Performance: kernel <code>/dev/vhost-*</code> devices</h3>
<p>Some backgrounds: as the para-virtualization techniques develop, the CPU
manufactures add a special set of instructions to realize hardware-assisted
virtualization. These instructions are only available in ring-0, while most VMM
softwares (except type-1 hypervisors) run in the user space. Thus OSes usually
provides APIs (or system calls) for use space programs to access these CPU
features. For example, Linux has kvm, macOS provides the Hypervisor
framework<sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup>.</p>
<p>In the kvm case, when a VM wants to send data out, it first triggers an VM-exit,
so control flow returns to kvm, kvm further returns to the user space VMM, for
example, QEMU. In most cases, QEMU will again call another system call to handle
the data. For example, the data is a network packet and QEMU writes the data to
a tap device. In these procedures we have two kernel-user space transitions:</p>
<ul>
<li>kvm(kernel) -&gt; qemu(user)</li>
<li>qemu(user) -&gt; system call <code>write()</code> (kernel)</li>
</ul>
<p>Kernel-user space transitions are expensive. Therefore <code>/dev/vhost-*</code> devices
are introduced. These devices run in the host kernel space. User space VMMs
delegate most VM data in/out operations to these devices through kvm&rsquo;s irqfd and
ioeventfd. This eliminates a lot of unnecessary kernel-user space transitions.
With the example above, for a network packet, now the control flow is like</p>
<ul>
<li>kvm(kernel) -&gt; vhost-net (kernel)</li>
<li>vhost-net (kernel) -&gt; tap device (kernel)</li>
</ul>
<h3 id="modularization-vhost-user">Modularization: vhost-user</h3>
<p>The example above off-loads the data processing to the guest kernel. On the
other hand, <strong>vhost-user</strong> off-loads data processing to another user space
program, which is called a backend device. The VMM and the device talk through a
unix domain socket. The benefit here is, now a backend device can be used by
different VMMs (QEMU, <a href="https://crosvm.dev/book/">crosvm</a>,
<a href="https://www.cloudhypervisor.org">Cloud Hypervisor</a>, etc.) as long as the VMM
implements the vhost protocol. New VMMs do not need to implement virtio devices
again.</p>
<p>Another benefit is security. A VMM usually needs to call many different kind of
of system calls while a backend device does not need that many. Developers can
thus sandbox the backend device process in a more fine-grained way, i.e., use a
more specific seccomp filter.</p>
<p>On the other hand, some virtio devices have to run as root (for example,
virtiofs<sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup>). With vhost-user, we just need to give privileges to the
device processes, while keeping the VMM process still a non-privileged one.</p>
<h2 id="vsock">Vsock</h2>
<p><strong>Vsock</strong><sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup> stands for virtual sockets. Vsock is a mechanism for
programs in the VM talking to programs in the host OS. Compared with other
inter-process communication methods, for example, unix domain sockets, vsock can
go across the VM boundary. However, compared with TCP/IP, vsock cannot go beyond
a physical machine. Vsock is also much simpler to configure. Vsock uses a
context id, which is just a number to address VMs. A context id is similar to
the IP address in TCP/IP, but no routing tables are necessary. The host has
context id <code>2</code>. A client program in a VM can reach a server program listening on
vsock port <code>$PORT</code> in the host by dialing <code>2:$PORT</code>.</p>
<p>On Linux, as I know, there are 2 different kind of implementations of vsock on
the host side.</p>
<ul>
<li>vhost-vsock: This implementation relies on the vhost protocol talked above.
Host applications can call <code>socket(AF_VSOCK, socket_type, 0)</code> to create a
vsock talking to a guest application. QEMU and crosvm use this model.</li>
<li>Firecraker model<sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>: vsocks on the host side are mapped to
unix domain sockets. Host applications listen or dial these sockets and the
VMM further forwards data into the VM. Firecraker and Cloud Hypervisor use
this model.</li>
</ul>
<p>On the guest side, it&rsquo;s the same, programs just need to call
<code>socket(AF_VSOCK, socket_type, 0)</code> to create a virtual socket.</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="https://doi.org/10.1145/1400097.1400108">virtio: towards a de-facto standard for virtual I/O devices</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p><a href="https://docs.oasis-open.org/virtio/virtio/v1.2/csd01/virtio-v1.2-csd01.html">Virtual I/O Device (VIRTIO) Version 1.2</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p><a href="https://www.redhat.com/en/blog/introduction-virtio-networking-and-vhost-net">Introduction to virtio-networking and vhost-net</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4">
<p><a href="https://developer.apple.com/documentation/hypervisor">Hypervisor framework</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5">
<p><a href="https://gitlab.com/virtio-fs/virtiofsd">virtiofsd</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6">
<p><a href="https://man7.org/linux/man-pages/man7/vsock.7.html">vsock(7) — Linux manual page</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7">
<p><a href="https://github.com/firecracker-microvm/firecracker/blob/main/docs/vsock.md">Using the Firecracker Virtio-vsock Device</a>&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

      </main>
    </article>
    
    
<section class="section" id="disqus"  >
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'changyuanme';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


    
    <footer class="section">
  <div class="container has-text-centered">
    &copy; 2014-2023 Lencerf
    | Generated by 
   <a href="http://gohugo.io" target="_blank" rel="nofollow">Hugo</a> | 
   <a href="http://creativecommons.org/licenses/by-nc/4.0/">CC BY-NC 4.0</a>
  </div>
</footer>


<script>
  function changeCSS(media, link) {
    if(media.matches) {
      link.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/atom-one-dark.min.css";
    } else {
      link.href = "https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/styles/foundation.min.css";
    }
  }

  var head = document.getElementsByTagName('HEAD')[0];
  var link = document.createElement('link');
  link.rel = 'stylesheet';
  head.appendChild(link);
  
  const media = window.matchMedia('(prefers-color-scheme: dark)');
  changeCSS(media, link);

  media.addListener(() => {
    changeCSS(media, link);
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/highlight.min.js"></script>  

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.10/languages/rust.min.js"></script>
 
 




  <script>hljs.initHighlightingOnLoad();</script>

  <script type="text/javascript" defer>
  (function($){
    $('.fancybox').fancybox();
  })(jQuery);
  </script>
  


<script type="text/javascript" defer>
  var changeExternalTarget = function() {
    function extractHostname(url) {
      var hostname;
      if (url.indexOf("://") > -1) {
          hostname = url.split('/')[2];
      }
      else {
          hostname = url.split('/')[0];
      }
      hostname = hostname.split(':')[0];
      return hostname;
    }
    links = document.getElementsByTagName('a')
    for (var i = 0; i < links.length; i++) {
        if (extractHostname(links[i].href) != window.location.hostname) {
        links[i].setAttribute('target', '_blank');
      }
    }
  }
  document.addEventListener('DOMContentLoaded', changeExternalTarget, false);
</script>
<script type="text/javascript" defer>
  var resize = function() {
    var bodyHeight = document.body.clientHeight;
    if (bodyHeight < window.innerHeight - 30) {
      document.getElementById("homeWhite").style.marginTop = 0.382 * (window.innerHeight - bodyHeight) + "px";
    } else {
      document.getElementById("homeWhite").style.marginTop = "30px";
    }
  }
  resize();
  window.addEventListener('resize', resize, false);
  function onElementHeightChange(elm, callback){
    var lastHeight = elm.clientHeight, newHeight;
    (function run(){
        newHeight = elm.clientHeight;
        if( lastHeight != newHeight )
            callback();
        lastHeight = newHeight;

        if( elm.onElementHeightChangeTimer )
            clearTimeout(elm.onElementHeightChangeTimer);

        elm.onElementHeightChangeTimer = setTimeout(run, 200);
    })();
  }
  onElementHeightChange(document.body, function(){
    resize();
    console.log("changed", document.body.clientHeight, window.innerHeight);

  });
</script>
    
  </body>
</html>